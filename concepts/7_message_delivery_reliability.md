邮件传递的可靠性

Proto.Actor可帮助您构建可靠的应用程序，这些应用程序在一台计算机中使用多个处理器内核（“向上扩展”）或分布在整个计算机网络中（“向外扩展”）。
进行此工作的关键抽象是，代码单元（actor）之间的所有交互都是通过消息传递发生的，这就是为什么在actor之间传递消息的确切语义应该保留自己的章节的原因。


为了给下面的讨论一些背景，考虑一个跨越多个网络主机的应用程序。
无论是发送到本地应用程序的actor还是远程actor，通信的基本机制都是相同的，但是当然，传递的延迟会有明显的差异（可能还取决于网络链路和消息的带宽）
尺寸）和可靠性。
如果发送远程消息，显然涉及更多步骤，这意味着可能会出错。
另一个方面是，本地发送将只传递对同一应用程序内消息的引用，而对所发送的基础对象没有任何限制，而远程传输将限制消息的大小。


安全地，悲观地押注，使您的actor写成每次互动都可能很遥远。
这意味着仅依赖始终保证且将在下面详细讨论的那些属性。
当然，在执行者的执行过程中会有一些开销。
如果您愿意牺牲整个位置的透明度（例如，在一组紧密协作的actor的情况下），则可以将它们始终放置在同一本地应用程序上，并在消息传递方面享有更严格的保证。
这种权衡的细节将在下面进一步讨论。


作为补充部分，我们给出一些关于如何在内置的基础之上建立更强可靠性的指示。
本章通过讨论“Dead Letter办公室”的作用来结束。


一般规则

这些是消息发送的规则（即Send方法，它也是Request模式的基础）：


最多一次交付，即没有保证的交付

每个发件人-收件人对的消息排序

通常在其他actor实现中也可以找到第一个规则，而第二个规则特定于Proto.Actor。


讨论：“最多一次”是什么意思？

在描述交付机制的语义时，有三个基本类别：


最多一次传递意味着对于传递给该机制的每条消息，该消息将被传递零次或一次；
随意地说，这意味着消息可能会丢失。


至少一次传递是指，对于传递给该机制的每条消息，可能都会多次尝试传递该消息，从而至少成功一次。
再次，更随意地说，这意味着消息可以重复但不会丢失。


精确一次传递意味着对传递给该机制的每条消息都精确地传递给收件人。
消息既不会丢失也不会重复。


第一个是最便宜的-最高的性能，最少的实现开销-因为它可以一劳永逸的方式完成，而无需在发送端或传输机制中保持状态。
第二个要求重试以抵消传输损失，这意味着在发送端保持状态并在接收端具有确认机制。
第三种是最昂贵的，并且因此具有最差的性能，因为除了第二种之外，它还要求状态保持在接收端，以过滤出重复的交货。


讨论：为什么没有保证的交货？

问题的核心在于此保证的确切含义：


消息是通过网络发送的吗？

该消息是否由其他主机接收？

该邮件是否已放入目标actor的邮箱？

该消息已开始由目标actor处理？

该消息已由目标actor成功处理？

这些中的每一个都有不同的挑战和成本，很明显，在某些情况下，任何消息传递库都无法遵守；
例如，考虑可配置邮箱的类型以及有界邮箱如何与第三点交互，或者甚至决定第五点的“成功”部分意味着什么。


同样，没有人需要可靠消息传递中的推理。
发送者知道交互是否成功的唯一有意义的方式是通过接收业务级别的确认消息，而Proto.Actor则无法自己做到这一点（Actor可以自己编写（我们也不编写“执行我的意思”的框架）
您也不会希望我们这样做）。


Proto.Actor包含分布式计算，并通过消息传递来使通信的易失性变得明确，因此它不会试图撒谎和模仿泄漏的抽象。
该模型已在Erlang中成功使用，需要用户围绕它设计应用程序。
您可以在Erlang文档Proto中了解有关此方法的更多信息.Actor会紧跟其后。


关于此问题的另一个角度是，通过仅提供基本保证，那些不需要更强可靠性的用例就无需支付实施成本。
总是有可能在基本的基础上增加更强的可靠性，但是不可能追溯性地删除可靠性以获得更多性能。


讨论：消息排序

更具体地说，规则是对于给定的一对actor，从第一个到第二个发送的消息不会被无序接收。
如下所示：


actorA1向A2发送消息M1，M2，M3


actorA3向A2发送消息M4，M5，M6


这意味着：1）如果交付了M1，则必须在M2和M3之前交付； 2）如果交付了M2，则必须在M3和M3之前交付； 3）如果交付了M4，则必须在M5和M6之前交付； 4）如果交付了M5。
必须在M6之前将其传递5）A2可以看到A1的消息与A3的消息交织在一起6）由于没有保证的传递，因此任何消息都可能被丢弃，即未到达A2


注意

请务必注意，Proto.Actor的保证适用于邮件进入收件人邮箱的顺序。

请注意，此规则不是传递性的：


actorA向actorC发送消息M1


然后actorA将消息M2发送给actorB


actorB将消息M2转发给actorC


actorC可以任何顺序接收M1和M2


因果传递顺序意味着在actorC之前，M2永远不会在M1之前收到（尽管它们中的任何一个都可能丢失）。
当A，B和C驻留在不同的网络主机上时，由于消息传递延迟不同，可能会违反此顺序，请参阅下文。


注意

actor创建被视为从父母发送给孩子的消息，具有与上述相同的语义。
以可能会与此初始创建消息重新排序的方式将消息发送给actor，这意味着消息可能不会到达，因为actor还不存在。
消息可能到达得太早的示例是创建一个远程部署的actorR1，将其引用发送给另一个远程actorR2，然后让R2将消息发送给R1。
定义明确的排序的一个示例是创建一个actor并立即向其发送消息的父母。

沟通失败

请注意，上面讨论的排序保证仅适用于actor之间的用户消息。 
actor的孩子的失败通过特殊的系统消息传达，该消息相对于普通用户消息没有排序。
特别是：


子actorC向其父P发送消息M


子actor失败，失败F


父actorP可能以M，F或F，M的顺序接收到两个事件


其原因是内部系统消息具有其自己的邮箱，因此用户和系统消息的入队呼叫的顺序不能保证其出队时间的顺序。


应用内（本地）消息发送规则

请谨慎操作本节！

建议不要依靠此部分中更高的可靠性，因为它会将您的应用程序绑定到仅本地部署：应用程序可能必须进行不同的设计（与仅使用某些actor本地的某些消息交换模式相对）。
适合在机器集群上运行。
我们的信条是“一次设计，按您希望的方式部署”，而要做到这一点，您仅应依赖总则。


本地消息发送的可靠性

Proto.Actor测试套件依赖于不丢失本地上下文中的消息（对于非错误条件测试也适用于远程部署），这意味着我们实际上尽了最大的努力来保持测试的稳定。
但是，本地发送操作由于与CLR上的常规方法调用相同的原因而可能失败：


StackOverflowException

OutOfMemoryException

其他：SystemException

此外，本地发送可能会以ProtoActor特定的方式失败：


如果邮箱不接受该消息（例如完整的BoundedMailbox）

如果接收方在处理消息时失败，或者已经终止

尽管第一个显然是有关配置的问题，但是第二个值得考虑：如果处理过程中出现异常，则消息的发送者不会获得反馈，而是将通知发送给Supervisor。
通常，这与外部观察者丢失的消息没有区别。


本地消息发送的顺序

假设严格的FIFO邮箱，则在某些情况下消除了消息订购保证的上述非传递性警告。
正如您将注意到的那样，这些内容实际上是非常微妙的，甚至将来的性能优化甚至有可能使整个段落无效。
可能不完整的反指示列表是：


在收到顶级actor的第一条答复之前，有一个锁可以保护内部临时队列，并且此锁是不公平的。
这意味着在actor构造期间到达不同发件人的入队请求（例如，涉及更多细节）可能会根据低级线程调度进行重新排序。
由于CLR上不存在完全公平的锁，因此无法修复。


在路由器的构造过程中使用相同的机制，更确切地说，是路由的ActorRef，因此，与路由器一起部署的actor存在相同的问题。


如上所述，问题在入队过程中涉及锁的任何地方都会发生，这也可能适用于自定义邮箱。


该列表已经过仔细地编辑，但是其他有问题的情况可能会逃脱我们的分析。


本地订购与网络订购有何关系

如上一段所述，本地消息在某些条件下发送服从的因果顺序。
如果远程消息传输也将遵循此顺序，则将转换为一条网络链路上的传递因果顺序，即是否恰好包含两个网络主机。
涉及多个链接，例如
上面提到的三个不同节点上的三个actor，则无法保证。


当前的远程传输不支持此操作（同样，这是由锁的非FIFO唤醒顺序引起的，这次是串行化连接建立）。


从未来的角度来看，有可能通过完全基于actor重新实现远程传输层来支持这种订购保证。
同时，我们正在研究提供其他低级传输协议，例如UDP或SCTP，它们可以通过再次删除此保证来实现更高的吞吐量或更低的延迟，这意味着在不同的实现方式之间进行选择将允许交易保证与性能之间的交易。


更高层次的抽象

基于ProtoActor核心的小型一致工具集，Proto.Actor还在其之上提供了强大的高层抽象。


讯息模式

如上所述，对可靠传递的要求的直接答案是显式ACK-RETRY协议。
最简单的形式是


一种识别单个消息以将消息与确认相关联的方法

重试机制，如果未及时确认，它将重发消息

接收者检测并丢弃重复项的方法

第三，由于不能保证也不能到达任何确认，因此有必要。 
Proto.Actor持久性模块的[[至少一次交付]]支持具有业务级别确认的ACK-RETRY协议。
可以通过跟踪通过[[至少一次传递]]发送的消息的标识符来检测重复项。
实现第三部分的另一种方法是使消息在业务逻辑级别上是幂等的。


实现这三个要求的另一个示例显示在：ref：reliable-proxy（现在已由[[至少一次交付]]取代）。


活动采购

事件源（和分片）使大型网站可以扩展到数十亿用户，其思想非常简单：当组件（思维actor）处理命令时，它将生成代表命令效果的事件列表。
除了将这些事件应用到组件的状态之外，还存储了这些事件。
这种方案的好处是，事件只会添加到存储中，而不会发生任何更改。
这样就可以完美复制和扩展此事件流的使用者（即，其他组件可能会使用事件流，以此来复制另一大陆上组件的状态或对更改做出反应）。
如果组件的状态丢失（由于机器故障或由于从缓存中推出而导致丢失），则可以通过重播事件流（通常使用快照来加快过程）来轻松地对其进行重构。 
：ref：event-sourcing由Proto.Actor Persistence支持。


带有明确确认的邮箱

通过实现自定义邮箱类型，可以在接收方的末端重试邮件处理，以处理临时故障。
这种模式在本地通信环境中非常有用，在这种情况下，交付保证足以满足应用程序的要求。


请注意，有关应用内（本地）消息Sends_规则的警告确实适用。


：ref：mailbox-acking中显示了此模式的示例实现。


Dead Letter

无法传递的消息（可以确定的消息）将传递给名为/ deadLetters的合成actor。
此交付是在尽力而为的基础上进行的；
即使在本地计算机中的单个应用程序内（例如在actor终止期间），它也可能会失败。
通过不可靠的网络传输发送的消息将丢失，而不会变成Dead Letter。


我应该为Dead Letter做什么？

该功能的主要用途是用于调试，尤其是在actor发送不一致的情况下（通常检查Dead Letter会告诉您发送者或接收者在途中某个地方设置有误）。
为了达到此目的，一个很好的做法是避免在可能的情况下发送到DeadLetters，即不时使用合适的Dead Letter记录器（请参见下文）运行您的应用程序并清理日志输出。
像其他所有练习一样，此练习需要明智地运用常识：很可能避免发送给终止的actor会使发送者的代码变得比调试输出清晰所带来的更多。


Dead Letter服务在发送保证方面遵循与所有其他消息发送相同的规则，因此不能用于实现保证发送。


我如何收到Dead Letter？

actor可以在事件流上订阅DeadLetter类，有关操作方法，请参见[[事件流]]。
从那时起，订阅的actor将收到在（本地）系统中发布的所有无效信件。
Dead Letter不会在网络上传播，如果要在一个地方收集它们，则必须为每个网络节点订阅一个actor，然后手动转发它们。
还请考虑在该节点上生成Dead Letter，该Dead Letter可以确定发送操作失败，对于远程发送，Dead Letter可以是本地系统（如果无法建立网络连接）或远程系统（如果要发送的actor）
到那时还不存在）。


（通常）不令人担忧的Dead Letter

每当actor没有根据自己的决定终止时，它发送给自己的某些消息就有可能丢失。
在通常是良性的复杂关机情况下，很容易发生一种情况：看到终止消息被丢弃意味着给出了两个终止请求，但是当然只有一个可以成功。
同样，如果在父级终止时父级仍在监视该children，则您可能会看到来自children的终止消息，同时停止以虚假字母形式出现的actor层次。


- Erlang文档：http://www.erlang.org/faq/academic.html 
- 没有人需要可靠的消息传递：http://www.infoq.com/articles/no-reliable-messaging